
import machine
import utime
import ujson


class Init:

    # -------------------------------------------------------------------------------------------------------
    def __init__(self, Dobby, Config):
        # Referance to dobby
        self.Dobby = Dobby
        # Var to hold configured Buttons
        self.Buttons = {}
        # Log Event
        self.Dobby.Log(1, "Button", "Initializing")
        
        # Loop over Buttons in config
        for Name, Button_Config in Config.items():
            # Make sure Name is a string
            Name = str(Name)
            # Add the Button to the Button dict
            self.Buttons[Name] = self.Button(self.Dobby, Name, Button_Config)
            # Check if the Button is ok
            if self.Buttons[Name].State is False:
                # Issue with Button detected disabling it
                self.Dobby.Log(2, "Button/" + Name, "Issue during setup, disabling the Button")
            else:
                # Subscribe to Button topic if at least one Button was ok
                self.Dobby.MQTT_Subscribe(self.Dobby.Config['System_Header'] + "/Button/" + self.Dobby.Config['Hostname'])
            
        self.Dobby.Log(0, "Button", "Initialization complete")


    # -------------------------------------------------------------------------------------------------------
    # Publish readings is requested to do so - Meant to be placed in dobbylib.On_Message()
    def On_Message(self, Topic, Payload):
        # Check if we need to take action based on topic
        if Topic == self.Dobby.Config['System_Header'] + "/Button/" + self.Dobby.Config['Hostname']:
            # Split payload to get Button and command
            Payload = Payload.split(" ")
            Name = str(Payload[0])
            Command = Payload[1]
            # 1 = command
            # Check if the Button is configured
            if self.Buttons.get(Name, None) is not None:
                # Button configured
                # Check what command we recieved
                ## return value as string
                if Command is "?":
                    # Add id to topic when publishing
                    # the payload will be a json generated by the Button class
                    self.Dobby.Log_Peripheral(Topic + "/" + str(Name), self.Buttons[Name].Get_json(), True)
            else:
                self.Dobby.Log(1, 'Button', "Unknown button: " + Name)


    # -------------------------------------------------------------------------------------------------------
    # Place this function in dobbylib.loop
    # This is where we check and do stuff if Interrupt_Counter changed
    def Loop(self):
        for Name in self.Buttons:
            self.Buttons[Name].Loop()


    # -------------------------------------------------------------------------------------------------------
    class Button:

        def __init__(self, Dobby, Name, Config):
            # Referance to dobby
            self.Dobby = Dobby

            # State
            ## False = Error/Unconfigured
            ## True = Running
            self.State = False
            
            # Name - This will be added to the end of the topic
            self.Name = str(Name)

            # Check if we got a config dict if no dict we cant configure
            if type(Config) is not dict:
                return

            # Interrupt counter, when a putten is press 1 is added to the counter
            self.Interrupt_Counter = 0
            self.Interrupt_Last = 0
            self.Interrupt_Diff = 0
            
            # Log Event
            self.Dobby.Log(0, "Button/" + self.Name, "Initializing")

            # Check if we got the needed config
            for Entry in ['Pin', 'Trigger']:
                if Config.get(Entry, None) is None:
                    self.Dobby.Log(2, "Button/" + Name, "Missing config: " + Entry + " - Unable to initialize Button")
                    return

            # Convert Wemos Pin to GPIO Pin Number
            self.Pin = self.Dobby.Pin_Monitor.To_GPIO_Pin(Config['Pin'])

            if self.Pin is False:
                self.Dobby.Log(2, "Button/" + id, "Invalid Pin Name: " + str(Config['Pin']) + " - Unable to initialize Button")
                return

            # Check typs is valid
            if Config['Trigger'] not in [1, 2]:
                self.Dobby.Log(2, "Button/" + id, "Invalid Trigger: " + str(Config['Trigger']) + " - Unable to initialize Button")
                return

            # Create Machine pin
            # self.Pin = machine.Pin(self.Pin, machine.Pin.IN)
            self.Pin = machine.Pin(self.Pin, machine.Pin.IN, machine.Pin.PULL_UP)
            # Register callback
            self.Pin.irq(trigger=machine.Pin.IRQ_RISING | machine.Pin.IRQ_FALLING, handler=self.Callback)
            # self.Pin.irq(trigger=Config['Trigger'], handler=self.Callback)

            # Get actions if any
            self.Disregard = 150
            if Config.get("Disregard", None) is not None:
                # Save value
                self.Disregard = int(Config["Disregard"])
                # Create vars to hols ms for the last two interrrups
                # used to calc how long the button was pressed
                # Log event
                self.Dobby.Log(0, "Button/" + self.Name, "Disregard set to: " + str(self.Disregard) + " ms")
            
            self.Ignore = None
            if Config.get("Ignore", None) is not None:
                # Save value
                self.Ignore = int(Config["Ignore"])
                # Create vars to hols ms for the last two interrrups
                # used to calc how long the button was pressed
                # Log event
                self.Dobby.Log(0, "Button/" + self.Name, "Ignore set to: " + str(self.Ignore) + " ms")

            # How long to ignore input for after last input
            self.Ignore_For = 500
            self.Ignore_Untill = 0
            
            
            self.MQTT_Message = None
            if Config.get("Message", None) is not None:
                # Save value
                self.MQTT_Message = Config["Message"]
                # Log event
                self.Dobby.Log(0, "Button/" + self.Name, "Trigger Message: " + str(self.MQTT_Message[0]) + " - " + self.MQTT_Message[1])
            
            self.Relay = None
            if Config.get("Relay", None) is not None:
                # Check if the relay is responding by getting state
                try:
                    # Get state and see if it fails
                    self.Dobby.Modules['relay'].Relays[self.Relay['Name']].State()
                except KeyError:
                    # Log event
                    self.Dobby.Log(3, "Button/" + self.Name, "Local relay not configured - Disabling message to relay")
                    # Disable the relay
                    self.Relay = None
                    # The system should still be working, so continue boot just disregarding this error

                if self.Relay != None:
                    # Save value
                    self.Relay = Config["Relay"]
                    # Log event
                    self.Dobby.Log(0, "Button/" + self.Name, "Trigger Relay: " + str(self.Relay['Name']) + " - " + str(self.Relay['State']))

            # Mark Button as ok aka enable it
            self.State = True

            # Log event
            self.Dobby.Log(0, "Button" + self.Name, "Initialization complete")


        # -------------------------------------------------------------------------------------------------------
        def Callback(self, pin):
            # Add one to counter to indicate the button was presses
            # Do not make this to big
            self.Interrupt_Counter = self.Interrupt_Counter + 1

            # Calc diff between current and last press
            self.Interrupt_Diff = utime.ticks_diff(utime.ticks_ms(), self.Interrupt_Last)
            # Store last interrrup ms
            self.Interrupt_Last = utime.ticks_ms()


        # -------------------------------------------------------------------------------------------------------
        def Loop(self):
            # If button is disabled do nothing
            if self.State is False:
                return
            # Check if Interrupt_Counter changed
            elif self.Interrupt_Counter > 0:
                # Disable irq temperaraly
                IRQ_State = machine.disable_irq()
                # Subtract one from self.Interrupt_Counter to indicate we acted on the button press
                self.Interrupt_Counter = self.Interrupt_Counter - 1
                # set to 0 if less then
                if self.Interrupt_Counter < 0:
                    self.Interrupt_Counter = 0
                # Enable irq again
                machine.enable_irq(IRQ_State)

                # Check if diff is less then Disregard is so ignore the push
                if self.Interrupt_Diff < self.Disregard:
                    # log event
                    self.Dobby.Log(0, "Button", self.Name + " - Disregard not elapsed, ignoreing press")
                    return

                # Dont check Ignore_Untill before here 
                # The code above will remove from the Interrupt_Counter untill we want to read presses again
                if utime.ticks_diff(utime.ticks_ms(), self.Ignore_Untill) < self.Ignore_For:
                    return
                # If are not ignoreing input then not the time of this input so we can ignore others
                else:
                    self.Ignore_Untill = utime.ticks_ms()

                # Build Topic
                Topic = self.Dobby.Config['System_Header'] + "/Button/" + self.Dobby.Config['Hostname'] + str(self.Name)
                # Log button was pressed
                self.Dobby.Log_Peripheral(Topic, "Pressed")
                
                # Take action as per specified
                ## Message
                if self.MQTT_Message is not None:
                    # Publish message
                    self.Dobby.Log_Peripheral(self.MQTT_Message[0], self.MQTT_Message[1])

                ## Relay
                if self.Relay is not None:
                    if self.Relay['State'] == "on":
                        # Change relay state
                        self.Dobby.Modules['relay'].Relays[self.Relay['Name']].On()
                        # Log event
                        self.Dobby.Log(0, "Button", self.Name + " - Local relay: " + self.Relay['Name'] + " on")
                    elif self.Relay['State'] == "off":
                        # Change relay state
                        self.Dobby.Modules['relay'].Relays[self.Relay['Name']].Off()
                        # Log event
                        self.Dobby.Log(0, "Button", self.Name + " - Local relay: " + self.Relay['Name'] + " off")
                    elif self.Relay['State'] == "toggle":
                        # Change relay state
                        self.Dobby.Modules['relay'].Relays[self.Relay['Name']].Toggle()
                        # Log event
                        self.Dobby.Log(0, "Button", self.Name + " - Local relay: " + self.Relay['Name'] + " toggle")