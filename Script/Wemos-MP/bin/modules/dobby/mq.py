
import machine
import ujson


class Init:

    # -------------------------------------------------------------------------------------------------------
    def __init__(self, Dobby, MQ_Config):
        # Referance to dobby
        self.Dobby = Dobby
        # Var to hold configured MQs
        self.MQs = {}
        # Log Event
        self.Dobby.Log(1, "MQ", "Initializing")
        
        # Loop over MQs in config
        for Name, Config in MQ_Config.items():
            # Make sure Name is a string
            Name = str(Name)
            # Add the MQ to the MQ dict
            self.MQs[Name] = self.MQ(self.Dobby, Name, Config)
            # Check if the MQ is ok
            if self.MQs[Name].OK is False:
                # Issue with MQ detected disabling it
                self.Dobby.Log(2, "MQ/" + Name, "Issue during setup, disabling the MQ")
            else:
                # Subscribe to MQ topic if at least one MQ was ok
                self.Dobby.MQTT_Subscribe(self.Dobby.Config['System_Header'] + "/MQ/" + self.Dobby.Config['Hostname'])
            
        self.Dobby.Log(0, "MQ", "Initialization complete")


    # -------------------------------------------------------------------------------------------------------
    # Publish readings is requested to do so - Meant to be placed in dobbylib.On_Message()
    def On_Message(self, Topic, Payload):
        # Check if we need to take action based on topic
        if Topic == self.Dobby.Config['System_Header'] + "/MQ/" + self.Dobby.Config['Hostname']:
            # Split payload to get MQ and command
            Payload = Payload.split(" ")
            Name = str(Payload[0])
            Command = Payload[1]
            # 1 = command
            # Check if the MQ is configured
            if self.MQs.get(Name, None) != None:
                # MQ configured
                # Check what command we recieved
                ## return value as string
                if Command is "?":
                    # Add id to topic when publishing
                    # the payload will be a json generated by the MQ class
                    self.Dobby.Log_Peripheral([Topic + "/" + str(Name), self.MQs[Name].Get_State()], True)
            else:
                self.Dobby.Log(1, 'MQ', "Unknown MQ: " + Name)


    # -------------------------------------------------------------------------------------------------------
    # Place this function in dobbylib.loop
    # This is where we check and do stuff if Interrupt_Counter changed
    def Loop(self):
        for Name in self.MQs:
            self.MQs[Name].Loop()


    # -------------------------------------------------------------------------------------------------------
    class MQ:

        def __init__(self, Dobby, Name, Config):
            # Referance to dobby
            self.Dobby = Dobby

            # Variable to indicate of the configuration of the MQ went ok
            ## False = Error/Unconfigured
            ## True = Running
            self.OK = False
            
            # Name - Referance name
            self.Name = str(Name)

            # Name - Referance name
            if Config.get("Flip", None) != None:
                # Set flip so we can check if try or false
                self.Flip = Config['Flip']
                if self.Flip not in [True, False]:
                    # Default to false
                    self.Flip = False

            # Default to false if not set
            else:
                self.Flip = False

            # Check if we got a config dict if no dict we cant configure
            if type(Config) is not dict:
                return
            
            # Log Event
            self.Dobby.Log(0, "MQ/" + self.Name, "Initializing")

            # Check if we got the needed config
            for Entry in ['Pin']:
                if Config.get(Entry, None) == None:
                    self.Dobby.Log(2, "MQ/" + Name, "Missing config: " + Entry + " - Unable to initialize MQ")
                    return

            # Check if PullUp is set to true 
            if Config.get("PullUp", None) != None:
                # Save value
                self.PullUp = bool(Config["PullUp"])
                # Log event
                self.Dobby.Log(0, "MQ/" + self.Name, "PullUp set to: " + str(self.PullUp))
            else:
                # Default to true
                self.PullUp = True

            # Save pin name to self.Pin
            self.Pin = Config['Pin']

            # Reset the pin
            try:
                self.Dobby.Pin_Monitor.Reserve(self.Pin, "MQ-" + self.Name, Pull=self.PullUp)
            except self.Dobby.Pin_Monitor.Error as e:
                # Pin in use unable to configure MQ
                self.Dobby.Log(2, "MQ/" + Name, "Pin in use - Unable to initialize MQ")
                # return so we dont set State to true aka mark the MQ as configured
                return

            # Convert Wemos Pin to GPIO Pin Number
            self.Pin = self.Dobby.Pin_Monitor.To_GPIO_Pin(Config['Pin'])

            # Check if the pin as i valid pin, Pin monitor returns false if pin is invalid
            if self.Pin is False:
                self.Dobby.Log(2, "MQ/" + id, "Invalid Pin Name: " + str(Config['Pin']) + " - Unable to initialize MQ")
                return

            # Create Machine pin
            # We cannot make the pin before we check PullUp, above
            if self.PullUp ==  True:
                self.Pin = machine.Pin(self.Pin, machine.Pin.IN, machine.Pin.PULL_UP)
            else:
                self.Pin = machine.Pin(self.Pin, machine.Pin.IN)
            
            # MQTT Message
            self.MQTT_Message = {}
            if Config.get("Message", None) != None:
                # For loop over entries in Messages if any
                for Entry in Config['Message']:
                    # Bool value to check if either topic or payload failed
                    Failure = False
                    # Check if we got both Topic and Payload
                    for Check in ['Topic', 'Payload']:
                        if Failure == True:
                            continue
                        # Missing topic or payload
                        if Config['Message'][Entry].get(Check, None) == None:
                            # Log event
                            self.Dobby.Log(2, "MQ/" + self.Name, "Trigger Message " + Entry + ": Missing " + Check + " - Disabling the '" + Entry + "' message")
                            # break since one is missing and we need both topic and payload
                            Failure = True

                    # Check if we failed to get the needed settings
                    if Failure == False:
                        # Save settings
                        self.MQTT_Message[Entry.lower()] = Config['Message'][Entry]
                        # log event
                        self.Dobby.Log(0, "MQ/" + self.Name, "Trigger Message " + Entry + " set to Topic: '" + self.MQTT_Message[Entry.lower()]['Topic'] + "' Payload: '" + self.MQTT_Message[Entry.lower()]['Payload'] + "'")
            
            # //////////////////////////////////////// Relay \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
            self.Relay = {}
            if Config.get("Relay", None) != None:
                # For loop over On/Off to check for both messages
                for Entry in Config['Relay']:
                    # Bool value to check if either topic or payload failed
                    Failure = False
                    # Check if we got both Topic and Payload
                    for Check in ['Name', 'State']:
                        if Failure == True:
                            continue
                        # Missing topic or payload
                        if Config['Relay'][Entry].get(Check, None) == None:
                            # Log event
                            self.Dobby.Log(2, "MQ/" + self.Name, "Trigger Relay " + Entry + ": Missing " + Check + " - Disabling the '" + Entry + "' message")
                            # break since one is missing and we need both topic and payload
                            Failure = True

                    # Check if we failed to get the needed settings
                    if Failure == False:
                        # Save settings
                        self.Relay[Entry.lower()] = Config['Relay'][Entry]
                        # log event
                        self.Dobby.Log(0, "MQ/" + self.Name, "Trigger Relay " + Entry + " set to Name: '" + self.Relay[Entry.lower()]['Name'] + "' Entry: '" + self.Relay[Entry.lower()]['State'] + "'")



            # //////////////////////////////////////// Dimmer \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
            self.Dimmer = {}
            if Config.get("Dimmer", None) != None:
                # For loop over On/Off to check for both messages
                for Entry in Config['Dimmer']:
                    # Bool value to check if either topic or payload failed
                    Failure = False
                    # Check if we got both Topic and Payload
                    for Check in ['Name', 'State']:
                        if Failure == True:
                            continue
                        # Missing topic or payload
                        if Config['Dimmer'][Entry].get(Check, None) == None:
                            # Log event
                            self.Dobby.Log(2, "MQ/" + self.Name, "Trigger Dimmer " + Entry + ": Missing " + Check + " - Disabling the '" + Entry + "' message")
                            # break since one is missing and we need both topic and payload
                            Failure = True

                    # Check if we failed to get the needed settings
                    if Failure == False:
                        # Save settings
                        self.Dimmer[Entry.lower()] = Config['Dimmer'][Entry]
                        # log event
                        self.Dobby.Log(
                            0,
                            "MQ/" + self.Name,
                            "Trigger Dimmer " + Entry + " set to Name: '" + self.Dimmer[Entry.lower()]['Name'] + "' Entry: '" + str(self.Dimmer[Entry.lower()]['State']) + "'")


            # Get optional config if any
            ## For
            self.For = {}
            # Check if we got 'for' set in config
            if Config.get("For", None) != None:
                for Entry in Config['For']:
                    # Check if the dobby.timer module is loaded
                    self.Dobby.Timer_Init()
                    # Add a timer
                    # 1 = Referance Name
                    # 2 = Timeout
                    # 3 = Callback
                    # 4 = Argument - Pass on or off
                    # Note For is active by creating <state> key with referance to timer in For dict
                    self.For[Entry.lower()] = self.Dobby.Sys_Modules['Timer'].Add(
                        self.Name + "-For-" + Entry,
                        Config['For'][Entry],
                        self.For_Check,
                        Entry.lower()
                    )
                    # Log event
                    self.Dobby.Log(0, "MQ/" + self.Name, Entry.lower() + " For set to: " + str(Config['For'][Entry]) + " ms")

            # Mark MQ as ok aka enable it
            self.OK = True

            # State of MQ - On/OFF aka True/False
            self.State = self.Get_State()

            # Log event
            self.Dobby.Log(0, "MQ/" + self.Name, "Initialization complete")


        # -------------------------------------------------------------------------------------------------------
        def Get_json(self):
            print("CODE ME")


        # -------------------------------------------------------------------------------------------------------
        def Get_State(self):
            # Returns the current state of the MQ in 'on' / 'off'
            # Flips the output of the pin since we are using pulldown and on will be 0 and off will be 1 on
            # Since fliped due to pull up then:
            # On = 0
            # off = 1
            # And if flip is active we reverse it all
            if self.Pin.value() == 0:
                if self.Flip == True:
                    return 'off'
                else:
                    return 'on'
            else:
                if self.Flip == True:
                    return 'on'
                else:
                    return 'off'


        # -------------------------------------------------------------------------------------------------------
        def For_Check(self, State):
            # State gets compared to current state and if equal Set_State is triggered

            # Compare pased state with current state
            if self.Get_State() == State:
                # Change state
                self.Set_State(State)


        # -------------------------------------------------------------------------------------------------------
        def Set_State(self, State):

              # Build Topic
                Topic = self.Dobby.Config['System_Header'] + "/MQ/" + self.Dobby.Config['Hostname'] + "/" + str(self.Name)

                # Log MQ was pressed
                self.Dobby.Log_Peripheral([Topic, self.Get_State()], True)

                # Take action as per specified
                ## Message
                try:
                    self.Dobby.Log_Peripheral(self.MQTT_Message[State])
                except KeyError:
                    pass

                ## Relay
                if self.Relay != None:
                    # Trigger the local relay with the provided settings
                    # We need a try here in case on or off is not set
                    try:
                        self.Dobby.Modules['relay'].Relays[self.Relay[State]['Name']].Set_State(self.Relay[State]['State'])
                    except KeyError:
                        pass
                
                ## Dimmer
                if self.Dimmer != None:
                    # Trigger the local Dimmer with the provided settings
                    # We need a try here in case on or off is not set
                    self.Dobby.Modules['dimmer'].Dimmers[self.Dimmer[State]['Name']].Set_Percent(self.Dimmer[State]['State'])
                    # try:
                    #     self.Dobby.Modules['Dimmer'].Dimmers[self.Dimmer[State]['Name']].Set_State(State)
                    # except KeyError:
                    #     pass

                # Save the current state to self.State
                self.State = State


        # -------------------------------------------------------------------------------------------------------
        def Loop(self):
            # If MQ is disabled do nothing
            if self.OK == False:
                return
