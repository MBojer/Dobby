# import dobbylib as Dobby

import machine
import utime
import ujson



class Dobby_Button:

    # -------------------------------------------------------------------------------------------------------
    def __init__(self, Dobby, Config):
        # Referance to dobby
        self.Dobby = Dobby
        # Var to hold configured Buttons
        self.Buttons = {}
        # Log Event
        self.Dobby.Log(1, "Button", "Initializing")
        
        One_Button_Configured = False

        # Loop over Buttons in config
        for Name, Button_Config in Config.items():
            # Make sure Name is a string
            Name = str(Name)
            # Add the Button to the Button dict
            self.Buttons[Name] = self.Button(self.Dobby, Name, Button_Config)
            # Check if the Button is ok
            if self.Buttons[Name] is False:
                # Issue with Button detected disabling it
                self.Dobby.Log(2, "Button/" + Name, "Issue during setup, disabling the Button")
            else:
                One_Button_Configured = True
        # Subscribe to Button topic if at least one Button was ok
        if One_Button_Configured is True:
            Topic = self.Dobby.Config['System_Header'] + "/Button/" + self.Dobby.Config['Hostname']
            # Log event
            self.Dobby.Log(0, 'MQTT', 'Subscribing to topic: ' + Topic)
            # Subscribe
            self.Dobby.MQTT_Client.subscribe(Topic)

        self.Dobby.Log(0, "Button", "Initialization complete")


    # -------------------------------------------------------------------------------------------------------
    # Publish readings is requested to do so - Meant to be placed in dobbylib.On_Message()
    def On_Message(self, Topic, Payload):
        # Check if we need to take action based on topic
        if Topic == self.Dobby.Config['System_Header'] + "/Button/" + self.Dobby.Config['Hostname']:
            # Split payload to get Button and command
            Payload = Payload.split(" ")
            Name = str(Payload[0])
            Command = Payload[1]
            # 1 = command
            # Check if the Button is configured
            if self.Buttons.get(Name, None) is not None:
                # Button configured
                # Check what command we recieved
                ## return value as string
                if Command is "?":
                    # Add id to topic when publishing
                    # the payload will be a json generated by the Button class
                    self.Dobby.Log_Peripheral(Topic + "/" + str(Name), self.Buttons[Name].Get_json(), True)
            else:
                self.Dobby.Log(1, 'Button', "Unknown button: " + Name)


    # -------------------------------------------------------------------------------------------------------
    # Place this function in dobbylib.loop
    # This is where we check and do stuff if Interrupt_Counter changed
    def Loop(self):
        for Name in self.Buttons:
            self.Buttons[Name].Loop()


    # -------------------------------------------------------------------------------------------------------
    class Button:

        def __init__(self, Dobby, Name, Config):
            # Referance to dobby
            self.Dobby = Dobby

            # State
            ## False = Error/Unconfigured
            ## True = Running
            self.State = False
            
            # Name - This will be added to the end of the topic
            self.Name = str(Name)

            # Interrupt counter, when a putten is press 1 is added to the counter
            self.Interrupt_Counter = 0

            # Log Event
            self.Dobby.Log(0, "Button/" + self.Name, "Initializing")

            # Check if we got the needed config
            for Entry in ['Pin', 'Trigger']:
                if Config.get(Entry, None) is None:
                    self.Dobby.Log(2, "Button/" + Name, "Missing config: " + Entry + " - Unable to initialize Button")
                    return

            # # Check/reserve if pin
            # if self.Dobby.Pin_Monitor_Reserve_Pin(Config['Pin']) is False:
            #     self.Dobby.Log(2, "Button/" + Button_id, "Pin in use: " + str(Config['Pin']) + " - Unable to initialize Button")
            #     return

            # Convert Wemos Pin to GPIO Pin Number
            self.Pin = self.Dobby.Pin_Monitor.To_GPIO_Pin(Config['Pin'])

            if self.Pin is False:
                self.Dobby.Log(2, "Button/" + id, "Invalid Pin Name: " + str(Config['Pin']) + " - Unable to initialize Button")
                return

            # Check typs is valid
            if Config['Trigger'] not in [1, 2]:
                self.Dobby.Log(2, "Button/" + id, "Invalid Trigger: " + str(Config['Trigger']) + " - Unable to initialize Button")
                return

            # Create Machine pin
            self.Pin = machine.Pin(self.Pin, machine.Pin.IN, machine.Pin.PULL_UP)
            # Register callback
            self.Pin.irq(trigger=Config['Trigger'], handler=self.Callback)

            # Get actions if any
            self.MQTT_Message = None
            if Config.get("Message", None) is not None:
                # Save value
                self.MQTT_Message = Config["Message"]
                # Log event
                self.Dobby.Log(0, "Button/" + self.Name, "Trigger Message: " + str(self.MQTT_Message[0]) + " - " + self.MQTT_Message[1])
            
            self.Relay = None
            if Config.get("Relay", None) is not None:
                # Save value
                self.Relay = Config["Relay"]
                # Log event
                self.Dobby.Log(0, "Button/" + self.Name, "Trigger Relay: " + str(self.Relay[0]) + " - " + self.Relay[1])

            # Mark Button as ok aka enable it
            self.State = True


        # -------------------------------------------------------------------------------------------------------
        def Callback(self, pin):
            # Add one to counter to indicate the button was presses
            self.Interrupt_Counter = self.Interrupt_Counter + 1


        # -------------------------------------------------------------------------------------------------------
        def Loop(self):
            # If button is disabled do nothing
            if self.State is False:
                return
            # Check if Interrupt_Counter changed
            elif self.Interrupt_Counter > 0:
                # Disable irq temperaraly
                IRQ_State = machine.disable_irq()
                # Subtract one from self.Interrupt_Counter to indicate we acted on the button press
                self.Interrupt_Counter = self.Interrupt_Counter - 1
                # set to 0 if less then
                if self.Interrupt_Counter < 0:
                    self.Interrupt_Counter = 0
                # Enable irq again
                machine.enable_irq(IRQ_State)
                # Log event
                self.Dobby.Log(0, "Button", self.Name + " pressed")
                
                # Take action as per specified
                ## Message
                if self.MQTT_Message is not None:
                    # Publish message
                    self.Dobby.Log_Peripheral(self.MQTT_Message[0], self.MQTT_Message[1])

                ## Relay
                if self.Relay is not None:
                    print("RelayRelayRelayRelayRelayRelayRelayRelayRelayRelayRelay")