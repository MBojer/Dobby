# import dobbylib as Dobby

import dht
import machine
import utime
import ujson


class DHT:

    # -------------------------------------------------------------------------------------------------------
    def __init__(self, Dobby, Config):
        # Referance to dobby
        self.Dobby = Dobby
        # Var to hold configured sensors
        self.Sensors = {}
        # Log Event
        self.Dobby.Log(1, "DHT", "Initializing")
        
        One_Sensor_Configured = False

        # Loop over sensors in config
        for Sensor_id, Sensor_Config in Config.items():
            # Make sure Sensor_id is a string
            Sensor_id = str(Sensor_id)
            # Add the sensor to the sensor dict
            self.Sensors[Sensor_id] = self.DHT_Sensor(self.Dobby, Sensor_id, Sensor_Config)
            # Check if the sensor is ok
            if self.Sensors[Sensor_id] is False:
                # Issue with sensor detected disabling it
                self.Dobby.Log(2, "DHT/" + Sensor_id, "Issue during setup, disabling the sensor")
            else:
                One_Sensor_Configured = True
        # Subscribe to dht topic if at least one sensor was ok
        if One_Sensor_Configured is True:
            Topic = self.Dobby.Config['System_Header'] + "/DHT/" + self.Dobby.Config['Hostname']
            # Log event
            self.Dobby.Log(0, 'MQTT', 'Subscribing to topic: ' + Topic)
            # Subscribe
            self.Dobby.MQTT_Client.subscribe(Topic)

        self.Dobby.Log(0, "DHT", "Initialization complete")


    # -------------------------------------------------------------------------------------------------------
    # Place this function in dobbylib.loop
    def Loop(self):
        # Read values from each sensor
        for Sensor_id in self.Sensors:
            # Check if the sensor is ok by checkg .state is true
            if self.Sensors[Sensor_id].State is False:
                return

            # Check if its time to read from the sensor
            if utime.ticks_diff(utime.ticks_ms(), self.Sensors[Sensor_id].Last_Read) > int(self.Sensors[Sensor_id].Rate) * 1000:
                # Read values
                self.Sensors[Sensor_id].Read()


    # -------------------------------------------------------------------------------------------------------
    # Publish readings is requested to do so - Meant to be placed in dobbylib.On_Message()
    def On_Message(self, Topic, Payload):
        # Check if we need to take action based on topic
        if Topic == self.Dobby.Config['System_Header'] + "/DHT/" + self.Dobby.Config['Hostname']:
            # Split payload to get sensor and command
            Payload = Payload.split(" ")
            Sensor_id = str(Payload[0])
            Command = Payload[1]
            # 1 = command
            # Check if the sensor is configured
            if self.Sensors.get(Sensor_id, None) is not None:
                # Sensor configured
                # Check what command we recieved
                ## return value as string
                if Command is "?":
                    # Add id to topic when publishing
                    # the payload will be a json generated by the sensor class
                    self.Dobby.Log_Peripheral(Topic + "/" + str(Sensor_id), self.Sensors[Sensor_id].Get_json(), True)


    # -------------------------------------------------------------------------------------------------------
    class DHT_Sensor:

        def __init__(self, Dobby, id, Config):
            # Referance to dobby
            self.Dobby = Dobby

            # State
            ## False = Error/Unconfigured
            ## True = Running
            self.State = False
            
            # id - This is the Number the device will post under
            self.id = str(id)

            # Log Event
            self.Dobby.Log(0, "DHT/" + self.id, "Initializing")

            # Check if we got the needed config
            for Entry in ['Pin', 'Type']:
                if Config.get(Entry, None) is None:
                    self.Dobby.Log(2, "DHT/" + id, "Missing config: " + Entry + " - Unable to initialize sensor")
                    return

            # Check if the pin is free
            add pin monitor stuff here

            # Create DHT sensor object
            if Config["Type"] is 11:
                self.Sensor = dht.DHT11(Dobby.Wemos_Pin_To_GPIO_Pin(Config['Pin']))
            elif Config["Type"] is 22:
                self.Sensor = dht.DHT22(Dobby.Wemos_Pin_To_GPIO_Pin(Config['Pin']))
            # Unknown type
            else:
                self.Dobby.Log(2, "DHT/" + self.id, "Unknown sensor type: " + Config["Type"] + "- Unable to initialize sensor")
                return

            # Var with last read so we can check agains itr
            self.Last_Read = 0
            
            # Error counter
            ## every time a read fails the error counter will get ++
            ## when = 10 the sensor will be disabeled
            ## it will be reset after a sucessfull read 
            self.Error_Count = 0
           
            self.Round_To = Config.get('Round', None)
            # Check if we need to round return value
            if Config.get('Round', None) is not None:
                self.Dobby.Log(0, "DHT/" + self.id, "Rounding to didgets: " + str(self.Round_To))
                # Convert self.Round_To to int
                self.Round_To = int(self.Round_To)
                       
            # Average
            ## Can be set via config
            # None = Returns last reading when asked for value
            # <int > 10> = Returns an rolling average over the last <int> reading
            ## Also provides Min and Max readings
            ## Min and Max is reset when values is requested via DHT_Sensor.read()
            self.Average = Config.get('Average' , None)
            # Check if we need to create a running average
            # self.Sensors[self.id]['Average'] contains the RunningVarage object if enabled
            if self.Average is not None:
                # Convert self.Average to int
                self.Average = int(self.Average)
                # Create rate var to hold sensor read interval if average is enabeled
                ## Defaults to 10 sec
                self.Rate = Config.get('Rate', 10)
                # Log event
                ## Refresh rate is only relevant if average is enabeled
                self.Dobby.Log(0, "DHT/" + self.id, "Refresh rate: " + str(self.Rate))
                self.Dobby.Log(0, "DHT/" + self.id, "Enabling Running Average of readings: " + str(self.Average))
                # import dobbyrunningaverage to enable runnin gaverage
                import dobbyrunningaverage
                # Init dobby running average lib for humidity reading
                self.Average_Humidity = dobbyrunningaverage.Running_Average(self.Average, self.Round_To)
                # Init dobby running average lib for temperature reading
                self.Average_Temperature = dobbyrunningaverage.Running_Average(self.Average, self.Round_To)

            # Do first read os we have values avalible just after boot
            self.Read()
            
            # Mark DHT Sensor as ok
            ## if its not it will get disabled after 10 failed reads
            self.State = True


        # -------------------------------------------------------------------------------------------------------
        def Read(self):
            # tries to read value from sensor
            ## False = Failed
            ## True = OK Value stored in 
            ### self.Sensor.humidity()
            ### self.Sensor.temperature()

            # try to read value    
            try:
                self.Sensor.measure()
            # Unable to read from the sensor
            except OSError:
                # Add to error count
                self.Error_Count = self.Error_Count + 1

                # Check if we reached max error count
                if self.Error_Count > 10:
                    self.Dobby.Log(2, "DHT/" + str(self.id), "Max error count reached disabling sensor - Error count: " + str(self.Error_Count))
                    # disable the sensor
                    self.State = False
                else:
                    # If average is false log as Warning so it can be seen early
                    if self.Average is None:
                        # Log event
                        Log_Level = 2
                    else:
                        Log_Level = 0
                    # Log event
                    self.Dobby.Log(Log_Level, "DHT/" + str(self.id), "Unable to read sensor values - Error count: " + str(self.Error_Count))

                # Save read time used to see when to read again
                self.Last_Read = utime.ticks_ms()
                
                # return when we get an error
                return

            # Reset error counter, because we got a good reading
            self.Error_Count = 0

            if self.Average is not None:
                # Add values to average
                self.Average_Humidity.Add(self.Sensor.humidity())
                self.Average_Temperature.Add(self.Sensor.temperature())

            # Save read time used to see when to read again
            self.Last_Read = utime.ticks_ms()
            # return true because we got a good reading
            return True

            # Add values to average
            self.Average_Humidity.Add(self.Sensor.humidity())
            self.Average_Temperature.Add(self.Sensor.temperature())



        # -------------------------------------------------------------------------------------------------------
        def Get_json(self, Reset=False):
            # If average is False we need to read the current valuer before building the json
            if self.Average is None:

                # Read value sine not refreshed by loop
                if self.Read() is False:
                    # build json
                    Return_dict = {'Error': 'Unable to read values from sensor'}
                # Check if we need to round
                ## Rounding
                elif self.Round_To is not None:
                    # build json
                    Return_dict = {
                        'Humidity': round(self.Sensor.humidity(), self.Round_To),
                        'Temperature': round(self.Sensor.temperature(), self.Round_To)
                    }

                ## Not rounding
                else:
                    # build json
                    Return_dict = {
                        'Humidity': self.Sensor.humidity(),
                        'Temperature': self.Sensor.temperature()
                    }
                    
                return ujson.dumps(Return_dict)
            
            # Average is enabeled so we need to build the json with values from dobbyrunningaverage lib
            ## Average_Humidity
            ## Average_Temperature
            else:
                # Rounding already donne by dobbyrunningaverage
                # build return dict
                json_dict = {
                    'Humidity': self.Average_Humidity.Get_dict(),
                    'Temperature': self.Average_Temperature.Get_dict()
                }
                # reset average min max if requested
                if Reset is True:
                    self.Average_Humidity.Reset()
                    self.Average_Temperature.Reset()
            
            # return json
            return ujson.dumps(json_dict)
                
        # -------------------------------------------------------------------------------------------------------
        def Loop(self):
            # If sensor is disabled do nothing
            if self.Sensors[Sensor_id].State is False:
                return
            # Read values only from sensors with Average enabeled
            # or when sensor is not disabeled aka state false
            if self.Average is None:
                return
            # Check if its time to read
            if utime.ticks_diff(utime.ticks_ms(), self.Last_Read > self.Rate * 1000):
                # Read values
                self.Read()